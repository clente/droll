% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/roll.R
\name{roll}
\alias{roll}
\alias{droll}
\alias{proll}
\alias{qroll}
\alias{rroll}
\title{The roll distribution}
\source{
The main algorithm for calculating dice probabilities comes from
\href{https://mathworld.wolfram.com/Dice.html}{MathWorld}.

Symbolic calculations are handled by
\href{https://cran.r-project.org/package=Ryacas}{Ryacas}, and, by extension, by
\href{https://www.yacas.org/}{Yacas}.
}
\usage{
roll(roll, precise = FALSE)

droll(x, roll)

proll(q, roll, lower.tail = TRUE)

qroll(p, roll, lower.tail = TRUE)

rroll(n, roll, verbose = TRUE)
}
\arguments{
\item{roll}{A roll expression (e.g., \code{2 * d6 + 5}).}

\item{precise}{Whether to return values with arbitrary precision.}

\item{x}{A numeric vector of outcomes.}

\item{q}{A numeric vector of outcomes.}

\item{lower.tail}{Whether to calculate \code{P[X <= x]} or \code{P[X > x]}.}

\item{p}{A numeric vector of probabilities.}

\item{n}{Number of random deviates to return.}

\item{verbose}{For \code{\link[=rroll]{rroll()}}, if \code{n = 1}, whether to print partial result of
the dice roll.}
}
\value{
For \code{\link[=roll]{roll()}}, a data frame with three columns: \code{outcome}, \code{count},
and \code{freq}. For \code{\link[=droll]{droll()}}, \code{\link[=proll]{proll()}}, \code{\link[=qroll]{qroll()}}, and \code{\link[=rroll]{rroll()}}, a numeric
vector.
}
\description{
Density, distribution function, quantile function, and random generation for
the discrete distribution described by a roll expression. See below for more
details.
}
\details{
Given a roll expression (i.e., an arithmetic expression involving dice),
\code{\link[=roll]{roll()}} calculates the complete distribution of the outcomes. This is
possible because the distribution is discrete and has a finite number of
outcomes.

From this distribution, \code{\link[=droll]{droll()}} returns the density, \code{\link[=proll]{proll()}} returns the
distribution function, \code{\link[=qroll]{qroll()}} returns the quantile function, and
\code{\link[=rroll]{rroll()}} generates random deviates. They mirror functions from the
\link{Distributions} family.
}
\section{Roll Expressions}{

A roll expression is a piece of R code that describes a dice roll with or
without modifiers, e.g., \code{2 * d6 + 5}.

Standard \href{https://en.wikipedia.org/wiki/Dice_notation}{dice notation} should
mostly work out of the box, with the notable exception of \code{NdX}, i.e., "roll
\code{N} dice with \code{X} faces and add the results". In this case, the user must
write \code{N * dX}; this also means that, when translating "roll a die with \code{X}
faces and multiply the result by \code{N}" to a roll expression, the user must
then write \code{dX * N}. All other expressions involving dice can usually be
pasted straight into these functions.

For more information, see the dice creating function \code{\link[=d]{d()}}.
}

\section{Built-in Dice}{

It is possible to define any die with \code{\link[=d]{d()}}, but some are already built-in.
Because of R's restrictions on what kind of object can be exported, they are
not readly available for the user, but can be used inside a roll expression
nontheless. These are the standard D&D dice: \code{d4}, \code{d6}, \code{d8}, \code{d10}, \code{d12},
\code{d20}, and \code{d100}.
}

\section{Arbitrary Precision}{

Most dice programs that can calculate probabilities are forced to round
their results due to the fact that these quantities might become
exceptionally low when dealing with a lot of dice. This, however, can lead
to error magnification.

In order to avoid rouding as much as possible, all functions described here
use \code{\link[Ryacas:yac_str]{Ryacas::yac_str()}} to run computations symbolically. By default,
results are converted to numeric vectors just before returning to the user,
but one is able to access the symbolic strings returned by Ryacas by setting
\code{precise = TRUE} on \code{\link[=roll]{roll()}}.
}

\examples{
# Complete distribution of 2d6 + 5
roll(2 * d6 + 5)

# Density of 2d6 + 5
droll(12, 2 * d6 + 5)

# Distribution function of 2d6 + 5
proll(12, 2 * d6 + 5)

# Quantile function of 2d6 + 5
qroll(0.5, 2 * d6 + 5)

# Roll 2d6 + 5 (generate random deviates)
set.seed(42)
rroll(1, 2 * d6 + 5)

}
